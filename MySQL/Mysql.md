**Mysql执行的过程**
- 连接器，连接器与客户端建立连接、获取权限、维持和管理连接
- 查询缓存，查询缓存中查找到则回直接返回给客户端（Mysql8移除了查询缓存）
- 解析器，在解析器中对SQL语句进行语法分析、语义分析
- 优化器，执行SQL查询调用存储引擎并返回结果

**Myisam和Innodb的区别**
- 数据的存储结构不同。MyISAM分为.frm文件存储表定义，.MYD(MYD)存储数据文件，.MYI(MYIndex)存储索引文件，叶子节点存储的是数据所在的地址，而不是数据。InnoDB分为.frm文件存储表定义，.ibd文件存储的是数据和索引文件，叶子节点存储的是整个数据行所有的数据。
- 存储空间的消耗不同
- 对事务的支持不同。MyISAM不支持事务，InnoDB支持事务
- 对锁的支持不同。MyISAM仅支持行级锁，InnoDB支持行锁
- 对外键的支持不同。MyISAM不支持外键，InoDB支持外键

**Mysql索引，Mysql索引类型，Mysql索引分类**
- Mysql索引是一种数据结构，类似于目录，可以提高数据的检索速度
- Mysql索引类型分为B-Tree、哈希索引、R-Tree、全文索引
- Mysql索引分类分为普通索引、唯一索引、主键索引、组合索引、覆盖索引、全文索引

**索引优缺点**
- 优点：大大提检索速度，降低数据库的IO成本
- 缺点：会降低更新表的速度，需要占用磁盘空间

**覆盖索引, 索引下推**
- 覆盖索引：从索引中就能查到的记录，避免了回表的产生
- 索引下推：通过存储引擎对索引中包含的所有字段过滤掉不符合条件的记录之后再回表

**Mysql索引设计，索引优化，索引失效**
- 索引设计：
    - 索引的列不允许为Null
    - 频繁作为查询条件的字段应该创建索引
    - 索引应该建在选择性高的字段上
    - 尽量为ORDER BY和 GROUP BY后面的字段建立索引
    - 多表关联时，要保证关联字段上一定有索引
    - 使用最小数据长度和最简数据类型
    - 频繁增删改的字段不要建立索引
- 索引优化：
    - 利用覆盖索引进行查询，避免回表
    - 使用顺序范围查找数据会很快
- 索引失效
    - 负向条件查询不能使用索引
    - 前导模糊查询不能命中索引
    - 索引列不能有计算或者函数
    - 组合索引因遵循最左前缀原则
    - 类型不一致会导致隐式转化
    - 必要时可以使用force index来强制查询sql走某个索引

**Mysql性能优化**
- SQL优化：
    - 分页优化：异步加载count和使用id进行过滤
    - 索引优化：参考索引设计和失效
    - Join优化：小表驱动大表
    - 排序优化：利用索引扫描做排序
    - UNION优化：使用union all
- 通过慢查询日志(long_query_time)定位SQL语句，使用expalin和show profile方法来分析sql查询慢的原因
- 可以使用主从同步和读写分离
- 典型的服务器配置(max_connections:最大客户端连接数，innodb_ buffer.pool size, innodb的缓冲池大小)
- 可以考虑提升硬件，比如使用SSD硬盘，内存增配

**聚簇索引，非聚簇索引**
- 聚簇索引：索引可以直接找到需要的数据，叶子节点存储的是行数据，查询效率更高，一般为主键索引
- 非聚簇索引：无法通过索引找到数据，需要二次回表查询，叶子节点存储的是主键ID，需要进行回表操作

**Mysql范式化**
- 属性不可分割，每个字段都应该是不可再拆分的
- 主键约束，表中要有主键，表中其他其他字段都依赖于主键
- 减少冗余，表中不能有其他表中存在的、存储相同信息的字段

**Explain分析**
- id：SELECT的查询序列号，SQL执行的顺序的标识，SQL从大到小的执行
- select_type：查询中子句的类型
- table：数据库中表名称或者简称
- type：访问类型，常用的类型有：ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）
- possible_keys：查询涉及到的字段上若存在索引
- key：显示MySQL实际决定使用的键（索引），必然包含在possible_keys中
- key_len：表示索引中使用的字节数
- ref：列与索引的比较
- rows：找到所需的记录所需要读取的行数
- Extra：
    - Using where：表明使用where过滤，进行了回表操作
    - Using filesort：对数据适用一个外部的索引排序，文件排序
    - Using temporary：查询结果排序时使用临时表，常见于排序order by和分组查询group by
    - Using index：表明进行覆盖索引
    - Using index condition：表明进行了索引下推

**事务，事务的特性**
- 事务是恢复与并发的基本单位
- 事务的4大特性：ACID 原子性、一致性、隔离性、持久性

**事务的隔离级别**
- 读未提交（Read Uncommitted 后续简称 RU）：可以读到未提交的读，基本上不会使用该隔离等级，所以暂时忽略。
- 读已提交（Read Committed 后续简称 RC）：存在幻读问题，对当前读获取的数据加记录锁。
- 可重复读（Repeatable Read 后续简称 RR）：不存在幻读问题，对当前读获取的数据加记录锁，同时对涉及的范围加间隙锁，防止新的数据插入，导致幻读。MySQL默认的隔离级别。
- 串行化（Serializable）：从 MVCC 并发控制退化到基于锁的并发控制，不存在快照读，都是当前读，并发效率急剧下降，不建议使用。

**MVCC，乐观锁，悲观锁，共享锁，排他锁**
- MVCC：多版本并发控制，实现对数据库的并发访问
- 悲观锁：它指的是对数据被外界修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制
- 乐观锁：乐观锁机制采取了更加宽松的加锁机制，悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。基于数据版本（ Version ）记录机制实现
- 共享锁：允许多个连接可以同一时刻并发的读取同一资源，互不干扰
- 排他锁：同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写

**脏读，幻读，不可重复读**
- 脏读：当前事务读到了另一个事务未提交的状态，事务没有实现隔离
- 幻读：两次查询同一批数据，发现有新数据被插入，主要是因为中途有其他事务对数据集进行了插入操作。（加了间隙锁解决该问题）
- 不可重复读：实现了事务的隔离性，但两次读取同一条数据的时候发现数据不一致了

**Mysql主从同步**
- 主库把数据变更写入binlog文件，主库I/O线程推送binlog至从库，从库I/O线程写入本地的relay log文件（与binlog格式一样），从库SQL线程读取relay log并重新串行执行一遍，得到与主库相同的数据

**Mysql死锁**
- 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环
- 如果出现死锁，可以用 SHOW INNODB STATUS 命令来确定最后一个死锁产生的原因
- 尽量使用较低的隔离级别，尽量使用索引访问数据使加锁更精确，选择合理的事务大小

**Mysql数据划分**
- 热数据：3个月内的订单数据，查询实时性较高，使用mysql进行存储，当然需要分库分表
- 冷数据A：3个月 ~ 12个月前的订单数据，查询频率不高，对于这类数据可以存储在ES中，利用搜索引擎的特性基本上也可以做到比较快的查询
- 冷数据B：1年前的订单数据，几乎不会查询，只有偶尔的查询需求，对于这类不经常查询的数据，可以存放到Hive中

**MySql分库分表**
- 按业务拆分：按业务模块将一个库分散到不同的库中
- 分表分库：大表拆分为多张子表，按平台进行拆分，按月份进行拆分，按订单ID取模拆分

**Mysql连接池**
- 池化技术的作用是减少资源创建次数，连接复用，提高程序的响应性能






















